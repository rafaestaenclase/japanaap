<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
<title>Practicar Japon√©s</title>
<style>
/* 1. Reset & Accesibilidad */
* {
  outline: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 0;
}
button {
  touch-action: manipulation;
  -webkit-user-select: none;
  user-select: none;
  outline: none;
  border: none; /* Consolidado */
  cursor: pointer;
  transition: .2s; /* Para los botones hover/click */
}
/* 2. Dise√±o de Layout Principal */
#studyDiv {
  position: fixed;
  height: calc(25vh - 10px);
  width: calc(100% - 55px);
  background: #fefff3;
  top: 0;
  left: 0;
  z-index: 100;
  overflow: scroll;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 5px;
}
#studyDiv * { font-size: 20px; }
#sectionsContainer {
  width: calc(100% - 44px);
  max-width: 960px;
  height: calc(75vh - 120px);
  margin-top: 25vh;
  overflow: scroll;
  padding-bottom: 120px;
}
#verticalBar {
  position: fixed;
  height: 100vh;
  width: 44px;
  top: 0;
  right: 0;
  background: #fefff3;
  border-radius: 12px;
  box-shadow: 0 5px 19px 1px rgba(0, 0, 0, .28);
  display: flex;
  z-index: 101;
  justify-content: center;
  flex-wrap: wrap;
  align-content: flex-start;
}
#webTitle {
  font-size: 2vh;
  height: 25vh;
  width: 100%;
  background: #620808;
  color: #ebebeb;
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: upright;
  font-weight: bold;
}
#categoryMenu {
  display: flex;
  max-height: 40vh;
  align-content: flex-start;
  flex-wrap: wrap;
  justify-content: center;
}

/* 3. Estilos de Secciones y Tarjetas */
.section {
  width: calc(100% - 10px);
  margin-bottom: 2px;
  padding: 5px;
  background: white;
}
.section-title {
  font-weight: bold;
  font-size: 1.2rem;
  margin-bottom: 10px;
  color: #2c3e50;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.level-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32%, 1fr));
  gap: 3px;
  justify-items: center;
  align-items: center;
}
.level-card {
  width: calc(100% - 30px);
  height: 40px;
  padding: 10px 15px;
  background: #fefefe;
  display: grid;
  place-items: center;
  box-shadow: 0 3px 10px rgb(196 192 180 / 52%);
  font-size: 14px;
  color: #000;
  text-align: center;
  cursor: pointer;
  justify-content: center;
  justify-items: center;
}
.level-card.selected {
  background: #0a0862;
  color: #fff;
  transform: translateY(-3px);
  box-shadow: 0 6px 15px rgba(0,0,0,.12);
}
.level-card h3 { margin:0; font-size:14px;} /* Ajuste de fuente en JS */
.level-card p { margin:0; font-size:12px; color:#7f8c8d; }

/* 4. Botones Flotantes y de Men√∫ */
#practiceContainer {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: #0a0862;
  padding: 10px 15px;
  box-shadow: 0 5px 19px 1px rgba(0,0,0,.28);
  display: none; /* Escondido por defecto */
  gap: 10px;
  z-index: 100;
  justify-content: center;
}
#fixedPlayButton {
  height: 48px;
  padding: 0 15px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  background: none;
  color: white;
}
#examToggleButton {
  width: 100%;
  max-height: 25vh;
  font-weight: 600;
  color: white;
  background: #086242;
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: upright;
  padding: 15px 0;
  margin-top: 5px;
}
#examToggleButton.active {
  border: 3px solid #cc2e2e;
  box-shadow: 0 3px 10px rgba(0,0,0,.15);
}
.categoryButton, #fullscreenToggle {
  height: 40px;
  width: 40px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  margin-top: 5px;
  background: none; /* Base para botones de barra vertical */
}
.categoryButton {
  background: #17171712;
  border: solid 1px gray;
  border-radius: 69px;
  text-shadow:
    -4px -4px 8px white, 4px -4px 8px white,
    -4px  4px 8px white, 4px  4px 8px white;
}

/* 5. Estilos de Tabla */
.study-table {
  border-collapse: collapse;
  width: 100%;
}
.study-table th {
  background: #f0f0f0;
}
.study-table th, .study-table td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: left;
}
.study-table td:last-child {
  font-weight: bold;
}
/* Estilos de t√≠tulo de categor√≠a */
/* Encabezados de categor√≠a fijos dentro del contenedor */
.category-block h2 {
  position: sticky;
  top: 0;
  z-index: 5;
  background: #ecf0f1;
  margin: 0;
  padding: 8px 2px;
  color: #2c3e50;
  font-weight: bold;
}

/* Clases no utilizadas en CSS, eliminadas: .examButton, #completedTimes, .instruction */
</style>
</head>
<body>
  <div id="verticalBar">
    <div id="webTitle">„Ç∏„É£„Éë„É≥„Ç¢„ÉÉ„Éó</div>
    <div id="categoryMenu"></div>
    <button id="examToggleButton">EXAMEN</button>
    <button id="fullscreenToggle">‚õ∂</button>
  </div>

<div id="studyDiv"></div>

<div id="sectionsContainer"></div>
<div id="practiceContainer">
  <button id="fixedPlayButton">Practicar</button>
</div>
<script src="./js/allLists.js"></script>
<script>



  // Mejorar la obtenci√≥n de referencias y usar destructuring para mayor legibilidad
  //que a√±ada las listas a all_lists
  const ALL_LISTS = [];
  for (const prop in window) {
      if (prop.endsWith("List") && window[prop] !== null && window[prop] !== undefined) {
          ALL_LISTS.push(window[prop]);
      }
  }
  const $ = (s) => document.getElementById(s);
  const container = $("sectionsContainer");
  const categoryMenu = $("categoryMenu");
  const fixedBtn = $("fixedPlayButton");
  const examBtn = $("examToggleButton");
  const studyDiv = $("studyDiv");
  const practiceContainer = $("practiceContainer");
  const fullscreenBtn = $("fullscreenToggle");

  let selected = null;
  let examMode = false;
  let examSel = [];

  /**
   * Crea el bloque de secci√≥n y sus tarjetas de nivel (grid).
   * @param {object} listObj - Objeto de lista de datos (ej. hiraganaList).
   * @param {HTMLElement} parent - El contenedor donde se a√±adir√°.
   */
  function createGrid(listObj, parent) {
    const section = document.createElement("div");
    section.id = listObj.listName;
    section.className = `section ${listObj.category}`;

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = listObj.name;

    // A√±adimos un icono indicador ‚ñº o ‚ñ≤
    const arrow = document.createElement("span");
    arrow.textContent = "‚ñº";
    arrow.style.marginLeft = "8px";
    arrow.style.fontSize = "0.9em";
    title.appendChild(arrow);

    // Contenedor del grid que se ocultar√° o mostrar√°
    const grid = document.createElement("div");
    grid.className = "level-grid";
    grid.style.display = "none"; // inicialmente oculto

    listObj.levels.forEach((lvl, i) => {
      const levelCard = document.createElement("div");
      levelCard.className = "level-card";
      levelCard.dataset.listName = listObj.listName;
      levelCard.dataset.level = lvl.level;
      levelCard.dataset.index = i;
      levelCard.innerHTML = `<h3>${lvl.name}</h3>`;
      levelCard.onclick = () => handleCardClick(levelCard);
      grid.appendChild(levelCard);
      fitTextInCard(levelCard);
    });

    // Al hacer clic en el t√≠tulo, alternar visibilidad del grid
    title.onclick = () => {
      const isVisible = grid.style.display === "grid";
      grid.style.display = isVisible ? "none" : "grid";
      arrow.textContent = isVisible ? "‚ñº" : "‚ñ≤";
    };

    section.appendChild(title);
    section.appendChild(grid);
    parent.appendChild(section);
  }

  /**
   * Genera los bloques de categor√≠as y los men√∫s de filtro.
   */
  function initCategoriesAndSections() {
    const categories = [...new Set(ALL_LISTS.map(l => l.category))];

    categories.forEach(cat => {
      // 1. Crear Bloque de Contenido (category-block)
      const categoryDiv = document.createElement("div");
      categoryDiv.className = "category-block";
      categoryDiv.style.display = "none"; // Ocultar por defecto para el filtro inicial
      categoryDiv.dataset.category = cat;

      const h2 = document.createElement("h2");
      h2.textContent =
        cat === "write" ? "‚úçÔ∏è Escritura" :
        cat === "vocabulary" ? "üìñ Vocabulario" :
        cat === "grammar" ? "üß© Gram√°tica" :
        cat;
      categoryDiv.appendChild(h2);

      ALL_LISTS.filter(l => l.category === cat).forEach(listObj => {
        createGrid(listObj, categoryDiv);
      });

      container.appendChild(categoryDiv);

      // 2. Crear Bot√≥n de Men√∫ (categoryButton)
      const btn = document.createElement("button");
      btn.textContent =
        cat === "write" ? "‚úèÔ∏è" :
        cat === "vocabulary" ? "üìñ" :
        cat === "grammar" ? "üß©" :
        "?";
      btn.id = cat;
      btn.className = "categoryButton";

      btn.onclick = () => filterSections(cat, btn);
      categoryMenu.appendChild(btn);
    });

    // Mostrar todas las secciones al inicio (ya que se ocultan por defecto)
    container.querySelectorAll(".category-block").forEach(b => b.style.display = "block");
  }

  /**
   * Filtra las secciones visibles al hacer clic en un bot√≥n de categor√≠a.
   * @param {string} cat - La categor√≠a a filtrar.
   * @param {HTMLElement} clickedBtn - El bot√≥n pulsado.
   */
    function filterSections(cat, clickedBtn) {
      // Deseleccionar card activa si existe
      if (selected) {
        selected.classList.remove("selected");
        selected = null;
        practiceContainer.style.display = "none";
      }

      currentCategory = cat; // Guardar categor√≠a activa
      const allBlocks = container.querySelectorAll(".category-block");
      const currentBlock = container.querySelector(`.category-block[data-category="${cat}"]`);
      const allBtns = document.querySelectorAll(".categoryButton");

      // Ocultar todos los bloques excepto el actual
      allBlocks.forEach(b => {
        b.style.display = (b === currentBlock) ? "block" : "none";
      });

      // Marcar solo el bot√≥n activo
      allBtns.forEach(b => {
        const isActive = (b === clickedBtn);
        b.style.border = isActive ? "4px solid #620808" : "1px solid gray";
        b.style.background = "none";
        b.style.color = "black";
      });

      saveState(); // Guardar estado
    }



  /**
   * Maneja el clic en una tarjeta de nivel.
   * @param {HTMLElement} card - La tarjeta de nivel (level-card) que se ha pulsado.
   */
  function handleCardClick(card) {
    if (examMode) {
      // Modo Examen: Selecci√≥n m√∫ltiple
      card.classList.toggle("selected");
      if (card.classList.contains("selected")) {
        examSel.push(card);
      } else {
        examSel = examSel.filter(x => x !== card);
      }
      practiceContainer.style.display = examSel.length > 0 ? "flex" : "none";

    } else {
      // Modo Pr√°ctica: Selecci√≥n simple
      const isDeselecting = selected === card;

      if (selected) selected.classList.remove("selected");

      if (isDeselecting) {
        selected = null;
        studyDiv.innerHTML = "";
      } else {
        card.classList.add("selected");
        selected = card;

        // Mostrar informaci√≥n
        const listName = card.dataset.listName;
        const levelIndex = parseInt(card.dataset.index);
        const currentList = ALL_LISTS.find(l => l.listName === listName);
        const currentLevel = currentList.levels[levelIndex];
        renderStudyDiv(currentLevel);
      }
      practiceContainer.style.display = selected ? "flex" : "none";
    }
    // Asegurarse de que el bot√≥n de pr√°ctica/examen tiene el estado correcto
    fixedBtn.classList.toggle("active", examMode ? examSel.length > 0 : !!selected);
  }

  /**
   * Ajusta el tama√±o de fuente de los elementos en studyDiv si desbordan.
   */
  function fitTextInStudyDiv() {
    // Usamos el contenedor principal para la l√≥gica de ajuste
    const maxHeight = studyDiv.clientHeight;
    const maxWidth = studyDiv.clientWidth;

    // Solo ajustamos la tabla si existe para evitar conflictos con el 'Ganbatte'
    const table = studyDiv.querySelector('.study-table');
    if (!table) return;

    let tableFontSize = 20; // Valor inicial del CSS
    const children = Array.from(table.querySelectorAll('th, td'));

    // Ajustar fuente reduciendo para que no desborde el ancho de la tabla
    while (table.scrollWidth > maxWidth && tableFontSize > 8) {
      tableFontSize -= 1;
      children.forEach(el => el.style.fontSize = tableFontSize + "px");
    }
  }

  /**
   * Dibuja la tabla de contenidos en studyDiv para el nivel seleccionado.
   * @param {object} level - El objeto de nivel con `name` y `items`.
   */
  function renderStudyDiv(level) {
    studyDiv.innerHTML = "";
    const title = document.createElement("p");
    title.textContent = level.name;
    Object.assign(title.style, {
      paddingLeft: "10px",
      marginBottom: "10px",
      fontWeight: "bold",
      color: "#2c3e50",
      fontSize: "1.2rem"
    });
    studyDiv.appendChild(title);

    // Crear tabla y aplicar clase CSS
    const table = document.createElement("table");
    table.className = "study-table";

    // Cabecera (thead)
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    ["Espa√±ol", "Japon√©s"].forEach(text => {
      const th = document.createElement("th");
      th.textContent = text;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Cuerpo (tbody)
    const tbody = document.createElement("tbody");
    level.items.forEach(item => {
      const tr = document.createElement("tr");
      const td1 = document.createElement("td");
      td1.textContent = item.q;
      const td2 = document.createElement("td");
      td2.textContent = item.a;

      tr.appendChild(td1);
      tr.appendChild(td2);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    studyDiv.appendChild(table);

    fitTextInStudyDiv();
  }

  /**
   * Muestra el mensaje de √°nimo por defecto en studyDiv.
   */
  function showGanbatte() {
    if (studyDiv.innerHTML.trim() === "") {
      studyDiv.innerHTML = "<h1 style='font-weight:bold;padding-left:10px;margin-bottom:0px'>„Åå„Çì„Å∞„Å£„Å¶</h1><h3 style='font-weight:bold;padding-left:10px;margin-top:0px'>√Ånimo</h3>";
    }
  }

  /**
   * Ajusta el tama√±o de fuente de un h3 dentro de un level-card para que quepa.
   * @param {HTMLElement} card - La tarjeta de nivel.
   */
  function fitTextInCard(card) {
    const h3 = card.querySelector("h3");
    if (!h3) return;

    let fontSize = 14; // tama√±o inicial en px (del CSS)
    h3.style.fontSize = fontSize + "px";

    // Reducir tama√±o hasta que quepa (usamos clientWidth y scrollWidth para detectar desborde)
    while (h3.scrollWidth > card.clientWidth && fontSize > 10) {
      fontSize -= 1;
      h3.style.fontSize = fontSize + "px";
    }
  }

  function saveState() {
    const openSections = [...document.querySelectorAll(".level-grid")]
      .filter(g => g.style.display === "grid")
      .map(g => g.parentElement.id);

    const state = {
      category: currentCategory,
      scroll: container.scrollTop,
      openSections,
      selectedCard: selected ? {
        listName: selected.dataset.listName,
        level: selected.dataset.level
      } : null
    };

    localStorage.setItem("jpState", JSON.stringify(state));
  }

  /**
   * Event listeners y configuraci√≥n inicial.
   */
  function setupListeners() {
    // Bot√≥n examen
    examBtn.onclick = () => {
      studyDiv.innerHTML = "";
      examMode = !examMode;
      examBtn.classList.toggle("active", examMode);
      fixedBtn.textContent = examMode ? "Comenzar" : "Practicar";
      examBtn.textContent = examMode ? "CANCELAR" : "EXAMEN";

      if (examMode) {
        studyDiv.innerHTML = '<h3 style="padding-left: 10px;">SELECCIONA LOS M√ìDULOS A A√ëADIR AL EXAMEN.</h3>';
        if (selected) {
          selected.classList.remove("selected");
          selected = null;
        }
      } else {
        examSel.forEach(c => c.classList.remove("selected"));
        examSel = [];
        showGanbatte();
      }
      practiceContainer.style.display = (examMode && examSel.length > 0) || (!examMode && selected) ? "flex" : "none";
      fixedBtn.classList.toggle("active", examMode ? examSel.length > 0 : !!selected);
    };

    // Bot√≥n practicar/comenzar
    fixedBtn.onclick = () => {
      if (examMode && examSel.length) {
        const examParams = examSel.map(c => `${c.dataset.listName}-${c.dataset.level}`).join(",");
        location.href = `practiceGround.html?exam=${examParams}`;
      } else if (!examMode && selected) {
        const listName = selected.dataset.listName;
        const level = selected.dataset.level;
        location.href = `practiceGround.html?play=${listName}&level=${level}`;
      }
    };

    // Bot√≥n de pantalla completa
    fullscreenBtn.onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.error(`Error al intentar entrar en pantalla completa: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    };

    // Manejo de scroll y almacenamiento local
    window.addEventListener("beforeunload", () =>
      localStorage.setItem("lastScrollPosition", container.scrollTop)
    );
    window.addEventListener("load", () => {
      const saved = JSON.parse(localStorage.getItem("jpState") || "{}");
      const isEmpty = Object.keys(saved).length === 0;
      if (isEmpty) {
        // Activar la primera categor√≠a por defecto
        const firstCategoryBtn = categoryMenu.querySelector(".categoryButton");
        if (firstCategoryBtn) {
          const firstCat = firstCategoryBtn.id;
          filterSections(firstCat, firstCategoryBtn);
        }
      }

      if (isEmpty) return;

      // Restaurar categor√≠a
      if (saved.category) {
        const btn = document.getElementById(saved.category);
        if (btn) filterSections(saved.category, btn);
      }

      // Restaurar secciones abiertas
      if (Array.isArray(saved.openSections)) {
        saved.openSections.forEach(id => {
          const section = document.getElementById(id);
          const grid = section?.querySelector(".level-grid");
          const arrow = section?.querySelector(".section-title span");
          if (grid && arrow) {
            grid.style.display = "grid";
            arrow.textContent = "‚ñ≤";
          }
        });
      }

      // Restaurar scroll
      if (typeof saved.scroll === "number") {
        setTimeout(() => container.scrollTo(0, saved.scroll), 100);
      }

      // Restaurar selecci√≥n previa
      if (saved.selectedCard) {
        const { listName, level } = saved.selectedCard;
        const card = container.querySelector(`.level-card[data-list-name="${listName}"][data-level="${level}"]`);
        if (card) {
          card.click();
        }
      }
    });


    // Evitar que el teclado aparezca en los campos de entrada
    document.addEventListener('focusin', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        event.target.blur();
      }
    });

    // Observador para re-mostrar Ganbatte si studyDiv se vac√≠a
    const observer = new MutationObserver(() => {
      // Usar setTimeout para asegurar que se ejecuta DESPU√âS de cualquier otra manipulaci√≥n del DOM
      setTimeout(showGanbatte, 0);
    });
    observer.observe(studyDiv, { childList: true, subtree: true, characterData: true });

    container.addEventListener("scroll", () => {
      saveState();
    });

    document.addEventListener("click", (e) => {
      if (e.target.closest(".section-title") || e.target.closest(".categoryButton") || e.target.closest(".level-card")) {
        setTimeout(saveState, 200);
      }
    });
  }

  // Inicializaci√≥n
  initCategoriesAndSections();
  setupListeners();
  showGanbatte();
</script>

</body>
</html>