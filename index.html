<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
<title>Practicar Japon√©s</title>
<style>
/* 1. Reset & Accesibilidad */
* {
  outline: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 0;
}
button {
  touch-action: manipulation;
  -webkit-user-select: none;
  user-select: none;
  outline: none;
  border: none; /* Consolidado */
  cursor: pointer;
  transition: .2s; /* Para los botones hover/click */
}
/* 2. Dise√±o de Layout Principal */
#studyDiv {
  position: fixed;
  height: calc(25vh - 21px);
  width: calc(100% - 65px);
  background: #fefff3;
  top: 0;
  left: 0;
  z-index: 100;
  overflow: scroll;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 10px;
}
#studyDiv * { font-size: 20px; }
#sectionsContainer {
  width: calc(100% - 44px);
  max-width: 960px;
  height: calc(75vh - 120px);
  margin-top: 25vh;
  overflow: scroll;
  padding-bottom: 120px;
}
#verticalBar {
  position: fixed;
  height: 100vh;
  width: 44px;
  top: 0;
  right: 0;
  background: #fefff3;
  border-radius: 12px;
  box-shadow: 0 5px 19px 1px rgba(0, 0, 0, .28);
  display: flex;
  z-index: 101;
  justify-content: center;
  flex-wrap: wrap;
  align-content: flex-start;
}
#webTitle {
  font-size: 2vh;
  height: 25vh;
  width: 100%;
  background: #620808;
  color: #ebebeb;
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: upright;
  font-weight: bold;
}
#categoryMenu {
  display: flex;
  max-height: 40vh;
  align-content: flex-start;
  flex-wrap: wrap;
  justify-content: center;
}

/* 3. Estilos de Secciones y Tarjetas */
.section {
  width: calc(100% - 30px);
  margin-bottom: 2px;
  padding: 15px;
  background: white;
}
.section-title {
  font-weight: bold;
  font-size: 1.2rem;
  margin-bottom: 10px;
  color: #2c3e50;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.level-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(32%, 1fr));
  gap: 3px;
  justify-items: center;
  align-items: center;
}
.level-card {
  width: calc(100% - 30px);
  height: 60px;
  padding: 15px;
  background: #fefefe;
  display: grid;
  place-items: center;
  box-shadow: 0 3px 10px rgb(196 192 180 / 52%);
  font-size: 14px;
  color: #000;
  text-align: center;
  cursor: pointer;
  justify-content: center;
  justify-items: center;
}
.level-card.selected {
  background: #0a0862;
  color: #fff;
  transform: translateY(-3px);
  box-shadow: 0 6px 15px rgba(0,0,0,.12);
}
.level-card h3 { margin:0; font-size:14px; } /* Ajuste de fuente en JS */
.level-card p { margin:0; font-size:12px; color:#7f8c8d; }

/* 4. Botones Flotantes y de Men√∫ */
#practiceContainer {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  background: #0a0862;
  padding: 10px 15px;
  box-shadow: 0 5px 19px 1px rgba(0,0,0,.28);
  display: none; /* Escondido por defecto */
  gap: 10px;
  z-index: 100;
  justify-content: center;
}
#fixedPlayButton {
  height: 48px;
  padding: 0 15px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  background: none;
  color: white;
}
#examToggleButton {
  width: 100%;
  max-height: 25vh;
  font-weight: 600;
  color: white;
  background: #086242;
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: upright;
  padding: 15px 0;
  margin-top: 5px;
}
#examToggleButton.active {
  border: 3px solid #cc2e2e;
  box-shadow: 0 3px 10px rgba(0,0,0,.15);
}
.categoryButton, #fullscreenToggle {
  height: 40px;
  width: 40px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  margin-top: 5px;
  background: none; /* Base para botones de barra vertical */
}
.categoryButton {
  background: #17171712;
  border: solid 1px gray;
  border-radius: 69px;
  text-shadow:
    -4px -4px 8px white, 4px -4px 8px white,
    -4px  4px 8px white, 4px  4px 8px white;
}

/* 5. Estilos de Tabla */
.study-table {
  border-collapse: collapse;
  width: 100%;
}
.study-table th {
  background: #f0f0f0;
}
.study-table th, .study-table td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: left;
}
.study-table td:last-child {
  font-weight: bold;
}
/* Estilos de t√≠tulo de categor√≠a */
.category-block h2 {
  padding: 5px;
  background: #ecf0f1;
  margin: 0 0 10px 0;
  color: #2c3e50;
}

/* Clases no utilizadas en CSS, eliminadas: .examButton, #completedTimes, .instruction */
</style>
</head>
<body>
  <div id="verticalBar">
    <div id="webTitle">„Ç∏„É£„Éë„É≥„Ç¢„ÉÉ„Éó</div>
    <div id="categoryMenu"></div>
    <button id="examToggleButton">EXAMEN</button>
    <button id="fullscreenToggle">‚õ∂</button>
  </div>

<div id="studyDiv"></div>

<div id="sectionsContainer"></div>
<div id="practiceContainer">
  <button id="fixedPlayButton">Practicar</button>
</div>
<script src="./js/allLists.js"></script>
<script>



  // Mejorar la obtenci√≥n de referencias y usar destructuring para mayor legibilidad
  //que a√±ada las listas a all_lists
  const ALL_LISTS = [];
  for (const prop in window) {
      if (prop.endsWith("List") && window[prop] !== null && window[prop] !== undefined) {
          ALL_LISTS.push(window[prop]);
      }
  }
  const $ = (s) => document.getElementById(s);
  const container = $("sectionsContainer");
  const categoryMenu = $("categoryMenu");
  const fixedBtn = $("fixedPlayButton");
  const examBtn = $("examToggleButton");
  const studyDiv = $("studyDiv");
  const practiceContainer = $("practiceContainer");
  const fullscreenBtn = $("fullscreenToggle");

  let selected = null;
  let examMode = false;
  let examSel = [];

  /**
   * Crea el bloque de secci√≥n y sus tarjetas de nivel (grid).
   * @param {object} listObj - Objeto de lista de datos (ej. hiraganaList).
   * @param {HTMLElement} parent - El contenedor donde se a√±adir√°.
   */
  function createGrid(listObj, parent) {
    const section = document.createElement("div");
    section.id = listObj.listName;
    section.className = `section ${listObj.category}`;

    const title = document.createElement("div");
    title.className = "section-title";
    title.textContent = listObj.listName;
    section.appendChild(title);

    const grid = document.createElement("div");
    grid.className = "level-grid";

    listObj.levels.forEach((lvl, i) => {
      const levelCard = document.createElement("div");
      levelCard.className = "level-card";
      levelCard.dataset.listName = listObj.listName;
      levelCard.dataset.level = lvl.level;
      levelCard.dataset.index = i;
      levelCard.innerHTML = `<h3>${lvl.name}</h3>`;
      levelCard.onclick = () => handleCardClick(levelCard);
      grid.appendChild(levelCard);

      // Ajustar texto inmediatamente despu√©s de la creaci√≥n
      fitTextInCard(levelCard);
    });

    section.appendChild(grid);
    parent.appendChild(section);
  }

  /**
   * Genera los bloques de categor√≠as y los men√∫s de filtro.
   */
  function initCategoriesAndSections() {
    const categories = [...new Set(ALL_LISTS.map(l => l.category))];

    categories.forEach(cat => {
      // 1. Crear Bloque de Contenido (category-block)
      const categoryDiv = document.createElement("div");
      categoryDiv.className = "category-block";
      categoryDiv.style.display = "none"; // Ocultar por defecto para el filtro inicial
      categoryDiv.dataset.category = cat;

      const h2 = document.createElement("h2");
      h2.textContent =
        cat === "write" ? "‚úçÔ∏è Escritura" :
        cat === "vocabulary" ? "üìñ Vocabulario" :
        cat === "grammar" ? "üß© Gram√°tica" :
        cat;
      categoryDiv.appendChild(h2);

      ALL_LISTS.filter(l => l.category === cat).forEach(listObj => {
        createGrid(listObj, categoryDiv);
      });

      container.appendChild(categoryDiv);

      // 2. Crear Bot√≥n de Men√∫ (categoryButton)
      const btn = document.createElement("button");
      btn.textContent =
        cat === "write" ? "‚úèÔ∏è" :
        cat === "vocabulary" ? "üìñ" :
        cat === "grammar" ? "üß©" :
        "?";
      btn.id = cat;
      btn.className = "categoryButton";

      btn.onclick = () => filterSections(cat, btn);
      categoryMenu.appendChild(btn);
    });

    // Mostrar todas las secciones al inicio (ya que se ocultan por defecto)
    container.querySelectorAll(".category-block").forEach(b => b.style.display = "block");
  }

  /**
   * Filtra las secciones visibles al hacer clic en un bot√≥n de categor√≠a.
   * @param {string} cat - La categor√≠a a filtrar.
   * @param {HTMLElement} clickedBtn - El bot√≥n pulsado.
   */
  function filterSections(cat, clickedBtn) {
    const allBlocks = container.querySelectorAll(".category-block");
    const currentBlock = container.querySelector(`.category-block[data-category="${cat}"]`);
    const allBtns = document.querySelectorAll(".categoryButton");

    // Determinar si YA es el √∫nico visible
    const isAlreadyActive = currentBlock.style.display !== "none" &&
      [...allBlocks].every(b => b === currentBlock || b.style.display === "none");

    if (isAlreadyActive) {
      // Mostrar todos los bloques
      allBlocks.forEach(b => b.style.display = "block");
      // Desactivar todos los botones
      allBtns.forEach(b => {
        b.style.background = "#17171712";
        b.style.color = "black";
      });
    } else {
      // Ocultar todos excepto el actual
      allBlocks.forEach(b => {
        b.style.display = (b === currentBlock) ? "block" : "none";
      });
      // Marcar bot√≥n activo
      allBtns.forEach(b => {
        const isActive = (b === clickedBtn);
        b.style.background = isActive ? "#0a0862" : "#17171712";
        b.style.color = isActive ? "white" : "black";
      });
    }
  }

  /**
   * Maneja el clic en una tarjeta de nivel.
   * @param {HTMLElement} card - La tarjeta de nivel (level-card) que se ha pulsado.
   */
  function handleCardClick(card) {
    if (examMode) {
      // Modo Examen: Selecci√≥n m√∫ltiple
      card.classList.toggle("selected");
      if (card.classList.contains("selected")) {
        examSel.push(card);
      } else {
        examSel = examSel.filter(x => x !== card);
      }
      practiceContainer.style.display = examSel.length > 0 ? "flex" : "none";

    } else {
      // Modo Pr√°ctica: Selecci√≥n simple
      const isDeselecting = selected === card;

      if (selected) selected.classList.remove("selected");

      if (isDeselecting) {
        selected = null;
        studyDiv.innerHTML = "";
      } else {
        card.classList.add("selected");
        selected = card;

        // Mostrar informaci√≥n
        const listName = card.dataset.listName;
        const levelIndex = parseInt(card.dataset.index);
        const currentList = ALL_LISTS.find(l => l.listName === listName);
        const currentLevel = currentList.levels[levelIndex];
        renderStudyDiv(currentLevel);
      }
      practiceContainer.style.display = selected ? "flex" : "none";
    }
    // Asegurarse de que el bot√≥n de pr√°ctica/examen tiene el estado correcto
    fixedBtn.classList.toggle("active", examMode ? examSel.length > 0 : !!selected);
  }

  /**
   * Ajusta el tama√±o de fuente de los elementos en studyDiv si desbordan.
   */
  function fitTextInStudyDiv() {
    // Usamos el contenedor principal para la l√≥gica de ajuste
    const maxHeight = studyDiv.clientHeight;
    const maxWidth = studyDiv.clientWidth;

    // Solo ajustamos la tabla si existe para evitar conflictos con el 'Ganbatte'
    const table = studyDiv.querySelector('.study-table');
    if (!table) return;

    let tableFontSize = 20; // Valor inicial del CSS
    const children = Array.from(table.querySelectorAll('th, td'));

    // Ajustar fuente reduciendo para que no desborde el ancho de la tabla
    while (table.scrollWidth > maxWidth && tableFontSize > 8) {
      tableFontSize -= 1;
      children.forEach(el => el.style.fontSize = tableFontSize + "px");
    }
    // Una vez ajustado el ancho, asegurar que la tabla no rompa el layout vertical
    // Aunque el CSS maneja overflow:scroll, un ajuste vertical estricto es m√°s complejo
    // y la limitaci√≥n por ancho es la prioridad para tablas.
  }

  /**
   * Dibuja la tabla de contenidos en studyDiv para el nivel seleccionado.
   * @param {object} level - El objeto de nivel con `name` y `items`.
   */
  function renderStudyDiv(level) {
    studyDiv.innerHTML = "";

    const title = document.createElement("p");
    title.textContent = level.name;
    Object.assign(title.style, {
      paddingLeft: "10px",
      marginBottom: "10px",
      fontWeight: "bold",
      color: "#2c3e50",
      fontSize: "1.2rem"
    });
    studyDiv.appendChild(title);

    // Crear tabla y aplicar clase CSS
    const table = document.createElement("table");
    table.className = "study-table";

    // Cabecera (thead)
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    ["Espa√±ol", "Japon√©s"].forEach(text => {
      const th = document.createElement("th");
      th.textContent = text;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Cuerpo (tbody)
    const tbody = document.createElement("tbody");
    level.items.forEach(item => {
      const tr = document.createElement("tr");
      const td1 = document.createElement("td");
      td1.textContent = item.q;
      const td2 = document.createElement("td");
      td2.textContent = item.a;

      tr.appendChild(td1);
      tr.appendChild(td2);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    studyDiv.appendChild(table);

    fitTextInStudyDiv();
  }

  /**
   * Muestra el mensaje de √°nimo por defecto en studyDiv.
   */
  function showGanbatte() {
    if (studyDiv.innerHTML.trim() === "") {
      studyDiv.innerHTML = "<h1 style='font-weight:bold;padding-left:10px;margin-bottom:0px'>„Åå„Çì„Å∞„Å£„Å¶</h1><h3 style='font-weight:bold;padding-left:10px;margin-top:0px'>√Ånimo</h3>";
    }
  }

  /**
   * Ajusta el tama√±o de fuente de un h3 dentro de un level-card para que quepa.
   * @param {HTMLElement} card - La tarjeta de nivel.
   */
  function fitTextInCard(card) {
    const h3 = card.querySelector("h3");
    if (!h3) return;

    let fontSize = 14; // tama√±o inicial en px (del CSS)
    h3.style.fontSize = fontSize + "px";

    // Reducir tama√±o hasta que quepa (usamos clientWidth y scrollWidth para detectar desborde)
    while (h3.scrollWidth > card.clientWidth - 15 && fontSize > 8) {
      fontSize -= 1;
      h3.style.fontSize = fontSize + "px";
    }
  }

  /**
   * Event listeners y configuraci√≥n inicial.
   */
  function setupListeners() {
    // Bot√≥n examen
    examBtn.onclick = () => {
      studyDiv.innerHTML = "";
      examMode = !examMode;
      examBtn.classList.toggle("active", examMode);
      fixedBtn.textContent = examMode ? "Comenzar" : "Practicar";
      examBtn.textContent = examMode ? "CANCELAR" : "EXAMEN";

      if (examMode) {
        studyDiv.innerHTML = '<h3 style="padding-left: 10px;">SELECCIONA LOS M√ìDULOS A A√ëADIR AL EXAMEN.</h3>';
        if (selected) {
          selected.classList.remove("selected");
          selected = null;
        }
      } else {
        examSel.forEach(c => c.classList.remove("selected"));
        examSel = [];
        showGanbatte();
      }
      practiceContainer.style.display = (examMode && examSel.length > 0) || (!examMode && selected) ? "flex" : "none";
      fixedBtn.classList.toggle("active", examMode ? examSel.length > 0 : !!selected);
    };

    // Bot√≥n practicar/comenzar
    fixedBtn.onclick = () => {
      if (examMode && examSel.length) {
        const examParams = examSel.map(c => `${c.dataset.listName}-${c.dataset.level}`).join(",");
        location.href = `practiceGround.html?exam=${examParams}`;
      } else if (!examMode && selected) {
        const listName = selected.dataset.listName;
        const level = selected.dataset.level;
        location.href = `practiceGround.html?play=${listName}&level=${level}`;
      }
    };

    // Bot√≥n de pantalla completa
    fullscreenBtn.onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.error(`Error al intentar entrar en pantalla completa: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    };

    // Manejo de scroll y almacenamiento local
    window.addEventListener("beforeunload", () =>
      localStorage.setItem("lastScrollPosition", container.scrollTop)
    );
    window.addEventListener("load", () =>
      container.scrollTo(0, Number(localStorage.getItem("lastScrollPosition") || 0))
    );

    // Evitar que el teclado aparezca en los campos de entrada
    document.addEventListener('focusin', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        event.target.blur();
      }
    });

    // Observador para re-mostrar Ganbatte si studyDiv se vac√≠a
    const observer = new MutationObserver(() => {
      // Usar setTimeout para asegurar que se ejecuta DESPU√âS de cualquier otra manipulaci√≥n del DOM
      setTimeout(showGanbatte, 0);
    });
    observer.observe(studyDiv, { childList: true, subtree: true, characterData: true });
  }

  // Inicializaci√≥n
  initCategoriesAndSections();
  setupListeners();
  showGanbatte();
</script>

</body>
</html>